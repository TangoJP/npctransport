/**
 *  \file simulation_data.cpp
 *  \brief description.
 *
 *  Copyright 2007-2012 IMP Inventors. All rights reserved.
 *
 */

#include <IMP/npctransport/simulation_data.h>
#include <IMP/npctransport/SitesPairScore.h>
#include <IMP/npctransport/internal/proto.hpp>
#include <IMP/npctransport/creating_particles.h>
#include <IMP/algebra/vector_generators.h>
#include <IMP/atom/estimates.h>
#include <IMP/atom/Selection.h>
#include <IMP/container/ConsecutivePairContainer.h>
#include <IMP/core/DistancePairScore.h>
#include <IMP/core/SphereDistancePairScore.h>
#include <IMP/core/XYZR.h>
#include <IMP/core/generic.h>
#include <IMP/display/LogOptimizerState.h>
#include <IMP/display/PymolWriter.h>
#include <IMP/display/restraint_geometry.h>
#include <IMP/example/optimizing.h>
#include <IMP/example/randomizing.h>


IMPNPCTRANSPORT_BEGIN_NAMESPACE

#define GET_VALUE(item, field, def)\
  (item.has_##field()?item.field().value():(def))
#define GET(item, field, def)\
  (item.has_##field()?item.field():(def))

core::ParticleType type_of_fga[]={core::ParticleType("fg0"),
                                 core::ParticleType("fg1"),
                                 core::ParticleType("fg2")};
core::ParticleType type_of_floata[]={core::ParticleType("kap"),
                                    core::ParticleType("crap0"),
                                    core::ParticleType("crap1")};
core::ParticleTypes type_of_fg(type_of_fga,
                              type_of_fga+sizeof(type_of_fga)/
                              sizeof(core::ParticleType));
core::ParticleTypes type_of_float(type_of_floata,
                              type_of_floata+sizeof(type_of_floata)/
                              sizeof(core::ParticleType));

SimulationData::SimulationData(std::string config_file,
                               std::string statistics_file,
                               bool quick):
    Object("SimulationData%1%") {
  statistics_file_name_= statistics_file;
  ::npctransport::Assignment data;
  std::ifstream file(config_file.c_str(), std::ios::binary);
  data.ParseFromIstream(&file);
  slack_=GET_VALUE(data, slack, 10);
  time_step_= GET_VALUE(data, time_step, 10000);
  attraction_spring_constant_
      =GET_VALUE(data,attraction_spring_constant, 1);
  repulsion_spring_constant_
      =GET_VALUE(data, repulsion_spring_constant, 1);
  side_=GET_VALUE(data, box_size, 1000);
  dump_interval_=GET(data, dump_interval, -1);
  if (!quick) {
    number_of_frames_= GET_VALUE(data, number_of_frames, 1);
    number_of_trials_= GET_VALUE(data, number_of_trials, 1);
  } else {
    number_of_frames_= 1;
    number_of_trials_=1;
  }
  range_=get_range(atom::get_einstein_diffusion_coefficient(radius_),
                   time_step_, attraction_spring_constant_,
                   .1);
<<<<<<< .mine

  // create particles and sites
  for (int i=0; i< data.fgs_size(); ++i) {
    core::ParticleType type=type_of_float[i];
    ParticlesTemp cur;
    for (int j=0; j< GET_VALUE(data.fgs(i), number, 0); ++j) {
      double dc=1.0;
      if (data.fgs(i).has_d_factor()) {
        dc= data.fgs(i).d_factor().value();
      }
      double rlf=1.0;
      if (data.fgs(i).has_rest_length_factor()) {
        dc= data.fgs(i).rest_length_factor().value();
      }
      cur.push_back(create_chain(this, data.fgs(i).number_of_beads().value(),
                                 data.fgs(i).radius().value(),
                                 dc, rlf,
                                 repulsion_spring_constant_,
                                 display::Color(.3,.3,.3), type, "fg"));
      if (data.fgs(i).has_interactions()) {
        int nsites= data.fgs(i).interactions().value();
        set_sites(type, nsites, data.fgs(i).radius().value());
      }
    }
    particles_[type]=cur;
  }
  for (int i=0; i< data.floaters_size(); ++i) {
    core::ParticleType type=type_of_float[i];
    ParticlesTemp cur;
    for (int j=0; j< data.floaters(i).number().value(); ++j) {
      double dc=1.0;
      if (data.fgs(i).has_d_factor()) {
        dc= data.floaters(i).d_factor().value();
      }
      cur.push_back(create_particle(this, data.floaters(i).radius().value(), dc,
                                    display::get_display_color(i),
                                    type, type.get_string()));
      if (data.floaters(i).has_interactions()) {
        int nsites= data.floaters(i).interactions().value();
        set_sites(type, nsites, data.floaters(i).radius().value());
      }
    }
    particles_[type]=cur;
  }
=======
  //std::cout << "range is " << range_ << std::endl;
>>>>>>> .r12575
}

Model *SimulationData::get_m() {
  set_was_used(true);
  if (!m_) {
    m_= new Model("NPC model %1%");
  }
  return m_;
}

OptimizerState *SimulationData::get_writer() {
  if (!writer_) {
    IMP_LOG(TERSE, "Setting up dump" << std::endl);
    IMP_NEW(display::PymolWriter, w, ("out.pym"));
    IMP_NEW(display::WriteOptimizerState, los, (w.get()));
    writer_=los;
    los->set_period(dump_interval_);
    IMP_NEW(TypedSitesGeometry, g, (get_diffusers()));
    for (compatibility::map<core::ParticleType,
             algebra::Vector3Ds>::const_iterator it= sites_.begin();
         it != sites_.end(); ++it) {
      g->set_sites(it->first, it->second);
    }
    los->add_geometry(g);
    IMP_NEW(display::RestraintSetGeometry, rsg,
            (get_static_restraints()));
    los->add_geometry(rsg);
    IMP_NEW(display::BoundingBoxGeometry, bbg, (get_box()));
    los->add_geometry(bbg);
  }
  return writer_;
}
atom::BrownianDynamics *SimulationData::get_bd() {
  if (!bd_) {
    bd_=new atom::BrownianDynamics(m_);
    bd_->set_maximum_time_step(time_step_);
    bd_->set_maximum_move(range_/4);
    if (dump_interval_ > 0) {
      bd_->add_optimizer_state(get_writer());
    }
  }
  return bd_;
}
container::ListSingletonContainer *
SimulationData::get_diffusers() {
  if (!diffusers_) {
    diffusers_ = new container::ListSingletonContainer(m_);
  }
  return diffusers_;
}
container::ClosePairContainer* SimulationData::get_cpc() {
  if (!cpc_) {
    cpc_= new container::ClosePairContainer(get_diffusers(),
                                            range_,
                                            slack_);
    cpc_->add_pair_filter(new container::ExclusiveConsecutivePairFilter());
  }
  return cpc_;
}
container::PredicatePairsRestraint* SimulationData::get_predr() {
  if (!predr_) {
    IMP_NEW(core::OrderedTypePairPredicate, otpp, ());
    otpp_=otpp;
    IMP_NEW(container::PredicatePairsRestraint, ppr, (otpp, get_cpc()));
    predr_=ppr;
    get_m()->add_restraint(ppr);
    IMP_NEW(core::SoftSpherePairScore, ssps, (repulsion_spring_constant_));
    ppr->set_unknown_score(ssps.get() );
  }
  return predr_;
}

void SimulationData::set_sites(core::ParticleType t0,
                               unsigned int n, double r) {
  algebra::Sphere3D s(algebra::get_zero_vector_d<3>(), r);
  algebra::Vector3Ds sites
      = algebra::get_uniform_surface_cover(s, n);
  sites_[t0]=algebra::Vector3Ds(sites.begin(), sites.begin()+n);
}
void SimulationData::add_interaction(core::ParticleType t0,
                                     core::ParticleType t1) {
  container::PredicatePairsRestraint *r= get_predr();
  {
    core::ParticleTypes ts;
    ts.push_back(t0);
    ts.push_back(t1);
    int v= otpp_->get_value(ts);
    set_sites_score(range_, attraction_spring_constant_,
                    repulsion_spring_constant_,
                    sites_[t0], sites_[t1], v, r);
  }
  {
    core::ParticleTypes ts;
    ts.push_back(t1);
    ts.push_back(t0);
    int v= otpp_->get_value(ts);
    set_sites_score(range_, attraction_spring_constant_,
                    repulsion_spring_constant_,
                    sites_[t1], sites_[t0], v, r);

  }
}


RestraintSet *SimulationData::get_static_restraints() {
  if (!static_) {
    static_= new RestraintSet("static restraints");
    m_->add_restraint(static_);
  }
  return static_;
}


void initialize_positions(SimulationData *sd,
                          const ParticlePairsTemp &extra_links) {
  example::randomize_particles(sd->get_diffusers()->get_particles(),
                               sd->get_box());
  sd->get_writer()->update();
  IMP_NEW(RestraintSet, rs, ("extra links"));
  sd->get_m()->add_restraint(rs);
  for (unsigned int i=0; i< extra_links.size(); ++i) {
    double d= core::XYZR(extra_links[i][0]).get_radius()
        +  core::XYZR(extra_links[i][1]).get_radius();
    IMP_NEW(core::HarmonicDistancePairScore, link,
            (d,sd->get_k()));
    Pointer<Restraint> r
        = create_restraint(link.get(), extra_links[i]);
    rs->add_restraint(r);
  }
  // ignore orientation as we don't really care, we just want connectivity
  RestraintsTemp rss
      = get_restraints(RestraintsTemp(1,sd->get_static_restraints()))
      + get_restraints(RestraintsTemp(1,rs));
  example::optimize_balls(sd->get_diffusers()->get_particles(),
                          rss,
                          sd->get_cpc()->get_pair_filters(),
                          PROGRESS);
  sd->get_m()->remove_restraint(rs);
  sd->get_writer()->update();
}

void SimulationData::write_geometry(std::string out) {
  IMP_NEW(display::PymolWriter, w, (out));
  IMP_NEW(TypedSitesGeometry, g, (get_diffusers()));
  for (compatibility::map<core::ParticleType,
         algebra::Vector3Ds>::const_iterator it= sites_.begin();
       it != sites_.end(); ++it) {
    g->set_sites(it->first, it->second);
  }
  w->add_geometry(g);
  IMP_NEW(display::RestraintSetGeometry, rsg,
          (get_static_restraints()));
  w->add_geometry(rsg);
  IMP_NEW(display::BoundingBoxGeometry, bbg, (get_box()));
  w->add_geometry(bbg);
}

#define UPDATE(frame, message, field, newvalue)  \
  (message).set_##field(static_cast<double>(frame)/(frame+1)*(message).field() \
                    + 1.0/(frame+1)*newvalue)


int SimulationData::get_number_of_interactions(Particle *a, Particle *b) const{
  if (core::get_distance(core::XYZR(a), core::XYZR(b)) > range_) return 0;
  const algebra::Vector3Ds &sa= sites_.find(core::Typed(a).get_type())->second;
  const algebra::Vector3Ds &sb= sites_.find(core::Typed(b).get_type())->second;
  int ct=0;
  for (unsigned int i=0; i< sa.size(); ++i) {
    for (unsigned int j=0; j< sb.size(); ++j) {
      if (algebra::get_distance(sa[i], sb[j]) < range_) {
        ++ct;
      }
    }
  }
  return ct;
}
boost::tuple<double,double,double, double>
SimulationData
::get_interactions_and_interacting(const ParticlesTemp &kaps,
                                   const vector<ParticlesTemps> &fgs) const {
  double interactions=0, interacting=0, bead_partners=0, chain_partners=0;
  for (unsigned int i=0; i < kaps.size(); ++i) {
    bool found=false;
    for (unsigned int j=0; j< fgs.size(); ++j) {
      for (unsigned int k=0; k < fgs[j].size(); ++k) {
        bool chain_found=false;
        for (unsigned int l=0; l< fgs[k].size(); ++l) {
          int num= get_number_of_interactions(kaps[i], fgs[i][j][k]);
          if (num>0) {
            interactions+=num;
            ++bead_partners;
            if (!found) ++interacting;
            found=true;
            if (!chain_found) ++chain_partners;
            chain_found=true;
          }
        }
      }
    }
  }
  return boost::make_tuple(interactions, interacting, bead_partners,
                           chain_partners);
}

void SimulationData::update_statistics() const {
  ::npctransport::Statistics stats;
  std::ifstream inf(statistics_file_name_.c_str(), std::ios::binary);
  if (inf) {
    stats.ParseFromIstream(&inf);
    inf.close();
  } else {
    for (unsigned int i=0; i<type_of_fg.size(); ++i) {
      if (particles_.find(type_of_fg[i]) != particles_.end()) {
        stats.add_fgs();
      }
    }
    for (unsigned int i=0; i<type_of_float.size(); ++i) {
      if (particles_.find(type_of_float[i]) != particles_.end()) {
        stats.add_floaters();
      }
    }
  }

  int nf= stats.number_of_frames();
  ParticlesTemp all;
  ParticlesTemps floaters;
  vector<ParticlesTemps> fgs;
  for (unsigned int i=0; i<type_of_fg.size(); ++i) {
    if (particles_.find(type_of_fg[i]) != particles_.end()) {
      fgs.push_back(ParticlesTemps());
      ParticlesTemp cur= particles_.find(type_of_fg[i])->second;
      for (unsigned int j=0; j< cur.size(); ++j) {
        atom::Hierarchy h(cur[j]);
        ParticlesTemp chain
            = get_as<ParticlesTemp>(atom::get_leaves(h));
        all+=chain;
        fgs.back().push_back(chain);
        double volume= atom::get_volume(h);
        UPDATE(nf, *stats.mutable_fgs(i), volume, volume);
        double length= core::get_distance(core::XYZ(chain[0]),
                                          core::XYZ(chain.back()));
        UPDATE(nf, *stats.mutable_fgs(i), length, length);
      }
    }
  }
  for (unsigned int i=0; i<type_of_float.size(); ++i) {
    if (particles_.find(type_of_float[i]) != particles_.end()) {
      floaters.push_back(particles_.find(type_of_float[i])->second);
      all+=floaters.back();
      double interactions, interacting, bead_partners, chain_partners;
      boost::tie(interactions, interacting, bead_partners, chain_partners)
          =get_interactions_and_interacting(floaters.back(), fgs);
      UPDATE(nf, *stats.mutable_floaters(i), interactions,
             interactions/floaters.back().size());
      UPDATE(nf, *stats.mutable_floaters(i), interacting,
             interacting/floaters.back().size());
      UPDATE(nf, *stats.mutable_floaters(i), interaction_partner_chains,
             chain_partners/interacting);
      UPDATE(nf, *stats.mutable_floaters(i), interaction_partner_beads,
             bead_partners/interacting);
    }
  }
  UPDATE(nf, stats, energy_per_particle, get_m()->evaluate(false)/all.size());

  stats.set_number_of_frames(nf+1);
  std::ofstream outf(statistics_file_name_.c_str(), std::ios::binary);
  stats.SerializeToOstream(&outf);
}

IMPNPCTRANSPORT_END_NAMESPACE
