/**
 *  \file simulation_data.cpp
 *  \brief description.
 *
 *  Copyright 2007-2012 IMP Inventors. All rights reserved.
 *
 */

#include <IMP/npctransport/simulation_data.h>
#include <IMP/npctransport/SitesPairScore.h>
#ifdef IMP_NPC_GOOGLE
#include "third_party/npc/module/data/npctransport.pb.h"
#else
#include "npctransport.pb.h"
#endif
#include <IMP/npctransport/creating_particles.h>
#include <IMP/npctransport/io.h>
#include <IMP/algebra/vector_generators.h>
#include <IMP/atom/estimates.h>
#include <IMP/atom/distance.h>
#include <IMP/rmf/atom_io.h>
#include <IMP/core/BoundingBox3DSingletonScore.h>
#include <IMP/atom/Selection.h>
#include <IMP/container/ConsecutivePairContainer.h>
#include <IMP/core/DistancePairScore.h>
#include <IMP/core/SphereDistancePairScore.h>
#include <IMP/core/HarmonicUpperBound.h>
#include <IMP/core/RestraintsScoringFunction.h>
#include <IMP/core/XYZR.h>
#include <IMP/core/generic.h>
#include <IMP/display/LogOptimizerState.h>
#include <IMP/display/PymolWriter.h>
#include <IMP/display/restraint_geometry.h>
#include <IMP/example/optimizing.h>
#include <IMP/example/randomizing.h>
#include <IMP/npctransport/rmf_links.h>
#include <RMF/FileHandle.h>


IMPNPCTRANSPORT_BEGIN_NAMESPACE

#define GET_VALUE(item, field, def)\
  (item.has_##field()?item.field().value():(def))
#define GET(item, field, def)\
  (item.has_##field()?item.field():(def))

core::ParticleType type_of_fga[]={core::ParticleType("fg0"),
                                 core::ParticleType("fg1"),
                                 core::ParticleType("fg2")};
core::ParticleType type_of_floata[]={core::ParticleType("kap"),
                                    core::ParticleType("crap0"),
                                    core::ParticleType("crap1")};
core::ParticleTypes type_of_fg(type_of_fga,
                              type_of_fga+sizeof(type_of_fga)/
                              sizeof(core::ParticleType));
core::ParticleTypes type_of_float(type_of_floata,
                              type_of_floata+sizeof(type_of_floata)/
                              sizeof(core::ParticleType));


SimulationData::SimulationData(std::string config_file,
                               std::string statistics_file,
                               bool quick):
    Object("SimulationData%1%") {
  statistics_file_name_= statistics_file;
  ::npctransport::Assignment data;
  std::ifstream file(config_file.c_str(), std::ios::binary);
  data.ParseFromIstream(&file);
  slack_=GET_VALUE(data, slack, 10);
  interaction_spring_constant_
      =GET_VALUE(data,interaction_spring_constant, 1);
  backbone_spring_constant_
      =GET_VALUE(data, backbone_spring_constant, 1);
  side_=GET_VALUE(data, box_size, 1000);
  dump_interval_=GET(data, dump_interval, -1);
  nonspecific_range_=GET_VALUE(data, nonspecific_range, 0);
  nonspecific_spring_constant_=GET_VALUE(data, nonspecific_spring_constant, 0);
  if (!quick) {
    number_of_frames_= GET_VALUE(data, number_of_frames, 1);
    number_of_trials_= GET_VALUE(data, number_of_trials, 1);
  } else {
    number_of_frames_= 2;
    number_of_trials_=2;
  }
  first_stats_=true;

  root_= new Particle(get_m());
  root_->add_attribute(get_simulation_data_key(), this);
  atom::Hierarchy hr=atom::Hierarchy::setup_particle(root_);
  root_->set_name("root");
  // create particles and sites
  bonds_= new container::PairContainerSet(get_m());
  create_fgs(data);
  create_floaters(data);
  time_step_= GET(data, time_step, 1);
  range_= GET(data, range, 1);
  for (int i=0; i< data.interactions_size(); ++i) {
    if (data.interactions(i).on_or_off().value()) {
      core::ParticleType type0(data.interactions(i).type0());
      core::ParticleType type1(data.interactions(i).type1());
      add_interaction(type0, type1);
    }
  }
  IMP_NEW(core::HarmonicUpperBound, hub, (0, backbone_spring_constant_));
  IMP_NEW(core::GenericBoundingBox3DSingletonScore<core::HarmonicUpperBound>,
          bbss,
          (hub.get(), get_box()));
  ParticlesTemp leaves= get_as<ParticlesTemp>(atom::get_leaves(get_root()));
  get_diffusers()->set_particles(leaves);
  box_restraint_=container::create_restraint(bbss.get(),
                                             get_diffusers(),
                                             "bounding box");
}

void SimulationData::create_floaters(const  ::npctransport::Assignment&data) {
  for (int i=0; i< data.floaters_size(); ++i) {
    IMP_LOG(TERSE, "create_floaters i=" << i <<std::endl);
    atom::Hierarchy cur_root
        = atom::Hierarchy::setup_particle(new Particle(get_m()));
    core::ParticleType type=type_of_float[i];
    IMP_LOG(TERSE, "   type " << type.get_string() <<std::endl);
    cur_root->set_name(type.get_string());
    atom::Hierarchy(get_root()).add_child(cur_root);
    double adc= GET_VALUE(data, angular_d_factor, 1);
    ParticlesTemp cur;
    for (int j=0; j< data.floaters(i).number().value(); ++j) {
      double dc=1.0;
      if (data.floaters(i).has_d_factor()) {
        dc= data.floaters(i).d_factor().value();
      }
      cur.push_back(create_particle(this, data.floaters(i).radius().value(),
                                    adc, dc,
                                    display::get_display_color(i),
                                    type, type.get_string()));
      cur_root.add_child(atom::Hierarchy::setup_particle(cur.back()));
      if (data.floaters(i).has_interactions()) {
        int nsites= data.floaters(i).interactions().value();
        set_sites(type, nsites, data.floaters(i).radius().value());
      }
    }
    particles_[type]=cur;
  }
  IMP_LOG(TERSE, " Done creating floaters "  <<std::endl);
}

void SimulationData::create_fgs(const  ::npctransport::Assignment&data) {
  for (int i=0; i< data.fgs_size(); ++i) {
    core::ParticleType type=type_of_fg[i];
    ParticlesTemp cur;
    atom::Hierarchy hi= atom::Hierarchy::setup_particle(new Particle(get_m()));
    hi->set_name(type.get_string());
    double adc= GET_VALUE(data, angular_d_factor, 1);
    atom::Hierarchy(get_root()).add_child(hi);
    for (int j=0; j< GET_VALUE(data.fgs(i), number, 0); ++j) {
      double dc=1.0;
      if (data.fgs(i).has_d_factor()) {
        dc= data.fgs(i).d_factor().value();
      }
      double rlf=1.0;
      if (data.fgs(i).has_rest_length_factor()) {
        dc= data.fgs(i).rest_length_factor().value();
      }
      cur.push_back(create_chain(this, data.fgs(i).number_of_beads().value(),
                                 data.fgs(i).radius().value(),
                                 adc, dc, rlf,
                                 backbone_spring_constant_,
                                 display::Color(.3,.3,.3), type, "fg", bonds_));
      hi.add_child(atom::Hierarchy(cur.back()));
      if (data.fgs(i).has_interactions()) {
        int nsites= data.fgs(i).interactions().value();
        set_sites(type, nsites, data.fgs(i).radius().value());
      }
    }
    particles_[type]=cur;
  }
}

Model *SimulationData::get_m() {
  set_was_used(true);
  if (!m_) {
    m_= new Model("NPC model %1%");
  }
  return m_;
}


// initialize a writer that outputs the particles hierarchy
OptimizerState *SimulationData::get_writer() {
  if (!writer_) {
    IMP_LOG(TERSE, "Setting up dump" << std::endl);
    RMF::FileHandle fh=RMF::create_rmf_file("output.rmf");
    IMP_NEW(rmf::SaveOptimizerState, los,
            (fh));
    writer_=los;
    los->set_period(dump_interval_);
    add_hierarchy(fh, atom::Hierarchy(get_root()));
    IMP::rmf::add_restraints(fh, RestraintsTemp(1, get_predr()));
    IMP::rmf::add_restraints(fh, chain_restraints_);
    IMP::rmf::add_restraints(fh, RestraintsTemp(1, box_restraint_));
    IMP_NEW(display::BoundingBoxGeometry, bbg, (get_box()));
    IMP::rmf::add_geometries(fh, display::Geometries(1, bbg));
  }
  return writer_;
}

void SimulationData::dump_geometry() {
  IMP_OBJECT_LOG;
  Pointer<display::Writer> w= display::create_writer("dump.pym");
  IMP_NEW(TypedSitesGeometry, g, (get_diffusers()));
  for (compatibility::map<core::ParticleType,
         algebra::Vector3Ds>::const_iterator it= sites_.begin();
       it != sites_.end(); ++it) {
    g->set_sites(it->first, it->second);
  }
  w->add_geometry(g);
  IMP_NEW(display::BoundingBoxGeometry, bbg, (get_box()));
  bbg->set_was_used(true);
  w->add_geometry(bbg);
}
void SimulationData::reset_rmf() {
  if (!writer_) return;
  get_writer();
  writer_->reset();
}
atom::BrownianDynamics *SimulationData::get_bd() {
  if (!bd_) {
    bd_=new atom::BrownianDynamics(m_);
    bd_->set_maximum_time_step(time_step_);
    bd_->set_maximum_move(range_/4);
    if (dump_interval_ > 0) {
      bd_->add_optimizer_state(get_writer());
    }
    RestraintsTemp rs= chain_restraints_;
    rs.push_back(box_restraint_);
    rs.push_back(predr_);
    IMP_NEW(core::RestraintsScoringFunction, rsf, (rs));
    bd_->set_scoring_function(rsf);
  }
  return bd_;
}
container::ListSingletonContainer *
SimulationData::get_diffusers() {
  if (!diffusers_) {
    diffusers_ = new container::ListSingletonContainer(m_);
  }
  return diffusers_;
}
container::ClosePairContainer* SimulationData::get_cpc() {
  if (!cpc_) {
    cpc_= new container::ClosePairContainer(get_diffusers(),
                                            range_,
                                            slack_);
    cpc_->add_pair_filter(new container::ExclusiveConsecutivePairFilter());
  }
  return cpc_;
}
container::PredicatePairsRestraint* SimulationData::get_predr() {
  if (!predr_) {
    IMP_NEW(core::OrderedTypePairPredicate, otpp, ());
    otpp_=otpp;
    IMP_NEW(container::PredicatePairsRestraint, ppr, (otpp, get_cpc()));
    predr_=ppr;
    IMP_NEW(LinearSoftSpherePairScore, ssps, (backbone_spring_constant_));
    ppr->set_unknown_score(ssps.get() );
  }
  return predr_;
}

void SimulationData::set_sites(core::ParticleType t0,
                               unsigned int n, double r) {
  algebra::Sphere3D s(algebra::get_zero_vector_d<3>(), r);
  algebra::Vector3Ds sites
      = algebra::get_uniform_surface_cover(s, n);
  sites_[t0]=algebra::Vector3Ds(sites.begin(), sites.begin()+n);
}
void SimulationData::add_interaction(core::ParticleType t0,
                                     core::ParticleType t1) {
  container::PredicatePairsRestraint *r= get_predr();
  {
    core::ParticleTypes ts;
    ts.push_back(t0);
    ts.push_back(t1);
    int v= otpp_->get_value(ts);
    set_sites_score(range_, interaction_spring_constant_,
                    nonspecific_range_, nonspecific_spring_constant_,
                    backbone_spring_constant_,
                    sites_[t0], sites_[t1], v, r);
  }
  {
    core::ParticleTypes ts;
    ts.push_back(t1);
    ts.push_back(t0);
    int v= otpp_->get_value(ts);
    set_sites_score(range_, interaction_spring_constant_,
                    nonspecific_range_, nonspecific_spring_constant_,
                    backbone_spring_constant_,
                    sites_[t1], sites_[t0], v, r);

  }
}


void initialize_positions(SimulationData *sd,
                          const ParticlePairsTemp &extra_links) {
  example::randomize_particles(sd->get_diffusers()->get_particles(),
                               sd->get_box());
  sd->get_writer()->update();
  RestraintsTemp rss=sd->get_chain_restraints();
  rss.push_back(sd->get_box_restraint());
  // pin fgs if not already pinned
  core::XYZs pinned;
  atom::Hierarchies chains= get_fg_chains(sd->get_root());
  for (unsigned int i=0; i< chains.size(); ++i) {
    if (core::XYZ(chains[i].get_child(0)).get_coordinates_are_optimized()) {
      pinned.push_back(core::XYZ(chains[i].get_child(0)));
      core::XYZ(chains[i].get_child(0)).set_coordinates_are_optimized(false);
    }
  }
  for (unsigned int i=0; i< extra_links.size(); ++i) {
    double d= core::XYZR(extra_links[i][0]).get_radius()
        +  core::XYZR(extra_links[i][1]).get_radius();
    IMP_NEW(core::HarmonicDistancePairScore, link,
            (d,sd->get_backbone_k(), "linker ps"));
    Pointer<Restraint> r
        = IMP::create_restraint(link.get(), extra_links[i]);
    rss.push_back(r);
  }
  IMP_NEW(core::RestraintsScoringFunction, sf, (rss));
  example::optimize_balls(sd->get_diffusers()->get_particles(),
                          sf->get_restraints(),
                          sd->get_cpc()->get_pair_filters(),
                          OptimizerStates(1, sd->get_writer()),
                          PROGRESS);
  IMP_LOG(TERSE, "Initial energy is " << sd->get_m()->evaluate(false)
          << std::endl);
  sd->get_writer()->update();
  for (unsigned int i=0; i< pinned.size(); ++i) {
    pinned[i].set_coordinates_are_optimized(true);
  }
}

void SimulationData::write_geometry(std::string out) {
  IMP_OBJECT_LOG;
  Pointer<display::Writer> w= display::create_writer(out);
  {
    IMP_NEW(TypedSitesGeometry, g, (get_diffusers()));
    for (compatibility::map<core::ParticleType,
           algebra::Vector3Ds>::const_iterator it= sites_.begin();
         it != sites_.end(); ++it) {
      g->set_sites(it->first, it->second);
    }
    w->add_geometry(g);
  }
  for (unsigned int i=0; i< chain_restraints_.size(); ++i) {
    IMP_NEW(display::RestraintGeometry, rsg,
            (chain_restraints_[i]));
    w->add_geometry(rsg);
  }
  {
    IMP_NEW(display::RestraintGeometry, rsg,
            (box_restraint_));
    w->add_geometry(rsg);
  }
  {
    IMP_NEW(display::RestraintGeometry, prsg,
            (predr_));
    w->add_geometry(prsg);
  }
  {
    IMP_NEW(display::BoundingBoxGeometry, bbg, (get_box()));
    w->add_geometry(bbg);
  }
}

#define UPDATE(frame, message, field, newvalue)  \
  (message).set_##field(static_cast<double>(frame)/(frame+1)*(message).field() \
                    + 1.0/(frame+1)*newvalue)


int SimulationData::get_number_of_interactions(Particle *a, Particle *b) const{
  if (core::get_distance(core::XYZR(a), core::XYZR(b)) > range_) return 0;
  const algebra::Vector3Ds &sa= sites_.find(core::Typed(a).get_type())->second;
  const algebra::Vector3Ds &sb= sites_.find(core::Typed(b).get_type())->second;
  int ct=0;
  for (unsigned int i=0; i< sa.size(); ++i) {
    for (unsigned int j=0; j< sb.size(); ++j) {
      if (algebra::get_distance(sa[i], sb[j]) < range_) {
        ++ct;
      }
    }
  }
  return ct;
}
boost::tuple<double,double,double, double>
SimulationData
::get_interactions_and_interacting(const ParticlesTemp &kaps,
                                   const base::Vector<ParticlesTemps> &fgs)
  const {
  double interactions=0, interacting=0, bead_partners=0, chain_partners=0;
  for (unsigned int i=0; i < kaps.size(); ++i) {
    bool found=false;
    for (unsigned int j=0; j< fgs.size(); ++j) {
      for (unsigned int k=0; k < fgs[j].size(); ++k) {
        bool chain_found=false;
        for (unsigned int l=0; l< fgs[j][k].size(); ++l) {
          int num= get_number_of_interactions(kaps[i], fgs[j][k][l]);
          if (num>0) {
            interactions+=num;
            ++bead_partners;
            if (!found) ++interacting;
            found=true;
            if (!chain_found) ++chain_partners;
            chain_found=true;
          }
        }
      }
    }
  }
  return boost::make_tuple(interactions, interacting, bead_partners,
                           chain_partners);
}

void SimulationData::update_statistics(const boost::timer &timer) const {
  ::npctransport::Statistics stats;
  if (first_stats_) {
    for (unsigned int i=0; i<type_of_fg.size(); ++i) {
      if (particles_.find(type_of_fg[i]) != particles_.end()) {
        stats.add_fgs();
        IMP_USAGE_CHECK(stats.fgs_size() ==static_cast<int>(i+1),
                        "Wrong size: " << stats.fgs_size());
      }
    }
    for (unsigned int i=0; i<type_of_float.size(); ++i) {
      if (particles_.find(type_of_float[i]) != particles_.end()) {
        stats.add_floaters();
      }
    }
    first_stats_=false;
  } else {
    std::ifstream inf(statistics_file_name_.c_str(), std::ios::binary);
    stats.ParseFromIstream(&inf);
    inf.close();
  }

  int nf= stats.number_of_frames();
  ParticlesTemp all;
  ParticlesTemps floaters;
  base::Vector<ParticlesTemps> fgs;
  for (unsigned int i=0; i<type_of_fg.size(); ++i) {
    if (particles_.find(type_of_fg[i]) != particles_.end()) {
      fgs.push_back(ParticlesTemps());
      ParticlesTemp cur= particles_.find(type_of_fg[i])->second;
      for (unsigned int j=0; j< cur.size(); ++j) {
        atom::Hierarchy h(cur[j]);
        ParticlesTemp chain
            = get_as<ParticlesTemp>(atom::get_leaves(h));
        all+=chain;
        fgs.back().push_back(chain);
        double volume= atom::get_volume(h);
        UPDATE(nf, *stats.mutable_fgs(i), volume, volume);
        double length= core::get_distance(core::XYZ(chain[0]),
                                          core::XYZ(chain.back()));
        UPDATE(nf, *stats.mutable_fgs(i), length, length);
        double radius_of_gyration= atom::get_radius_of_gyration(chain);
        UPDATE(nf, *stats.mutable_fgs(i), radius_of_gyration,
               radius_of_gyration);
      }
    }
  }
  for (unsigned int i=0; i<type_of_float.size(); ++i) {
    if (particles_.find(type_of_float[i]) != particles_.end()) {
      floaters.push_back(particles_.find(type_of_float[i])->second);
      all+=floaters.back();
      double interactions, interacting, bead_partners, chain_partners;
      boost::tie(interactions, interacting, bead_partners, chain_partners)
          =get_interactions_and_interacting(floaters.back(), fgs);
      UPDATE(nf, *stats.mutable_floaters(i), interactions,
             interactions/floaters.back().size());
      UPDATE(nf, *stats.mutable_floaters(i), interacting,
             interacting/floaters.back().size());
      UPDATE(nf, *stats.mutable_floaters(i), interaction_partner_chains,
             chain_partners/interacting);
      UPDATE(nf, *stats.mutable_floaters(i), interaction_partner_beads,
             bead_partners/interacting);
    }
  }
  UPDATE(nf, stats, energy_per_particle, get_m()->evaluate(false)/all.size());

  UPDATE(nf, stats, seconds_per_iteration, timer.elapsed());

  stats.set_number_of_frames(nf+1);
  std::ofstream outf(statistics_file_name_.c_str(), std::ios::binary);
  stats.SerializeToOstream(&outf);
}


display::Geometry* SimulationData::get_static_geometry() {
  if (!static_geom_) {
    IMP_NEW(display::BoundingBoxGeometry, bbg, (this->get_box()));
    static_geom_=bbg;
  }
  return static_geom_;
}


atom::Hierarchies get_fg_chains(atom::Hierarchy root) {
  atom::Hierarchies ret;
  if (root.get_number_of_children() >0) {
    atom::Hierarchy c= root.get_child(0);
    if (core::Typed::particle_is_instance(c)) {
      core::ParticleType t=core::Typed(c).get_type();
      if (std::find(type_of_fg.begin(),
                    type_of_fg.end(), t) != type_of_fg.end()) {
        return atom::Hierarchies(1, root);
      }
    }
  }
  for (unsigned int i=0; i< root.get_number_of_children(); ++i) {
    ret+= get_fg_chains(root.get_child(i));
  }
  return ret;
}

IMPNPCTRANSPORT_END_NAMESPACE
