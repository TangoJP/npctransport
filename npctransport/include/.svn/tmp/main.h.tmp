/**
 *  \file main.h
 *  \brief Helper functions for executable .cpp files
 *
 *  Copyright 2007-2010 IMP Inventors. All rights reserved.
 */

#ifndef IMPNPCTRANSPORT_MAIN_H
#define IMPNPCTRANSPORT_MAIN_H


#ifdef IMP_NPC_MAIN

#include "npctransport_config.h"
#include <IMP/algebra.h>
#include <IMP/core.h>
#include <IMP/atom.h>
#include <IMP/display.h>
#include <IMP/rmf.h>
#include <IMP.h>
#include <IMP/container.h>
#include <IMP/npctransport.h>
#include <numeric>
#include <cmath>
#include <iostream>

// use the example code for now to work bugs out of it
#include <IMP/example/creating_restraints.h>
#include <IMP/example/randomizing.h>
#include <IMP/example/counting.h>
#include <IMP/example/optimizing.h>

#ifdef IMP_NPC_GOOGLE
#include "internal/google_main.h"
#else
#include "internal/boost_main.h"
#endif


#define IMP_NPC_STARTUP                                                 \
  IMP_NPC_START_INT;                                                    \
  IMP_NPC_PRINTHELP;                                                    \
  assign_ranges(FLAGS_configuration, FLAGS_assignments, FLAGS_work_unit); \
  IMP_NEW(SimulationData, sd,(FLAGS_assignments, FLAGS_statistics,      \
                              FLAGS_quick))

IMP_NPC_PARAMETER_INT(work_unit, -1, "The work unit");
IMP_NPC_PARAMETER_STRING(configuration, "configuration.pb",
                         "Configuration file");
IMP_NPC_PARAMETER_STRING(assignments, "assignments.pb", "Assignments file");
IMP_NPC_PARAMETER_STRING(statistics, "statistics.pb", "Statistics file");
IMP_NPC_PARAMETER_STRING(final_configuration, "final.pym",
                         "Where to write the final config");
IMP_NPC_PARAMETER_BOOL(quick, false, "Reduce all steps to the minimum");

#define IMP_NPC_LOOP(links)                                     \
  for (unsigned int i=0; i< sd->get_number_of_trials(); ++i) {  \
    initialize_positions(sd, links);                            \
    sd->get_bd()->set_log_level(SILENT);                        \
    sd->get_bd()->optimize(sd->get_number_of_frames());         \
    sd->update_statistics();                                    \
    sd->write_geometry(FLAGS_final_configuration);              \
  }

<<<<<<< .mine
=======
struct IMPNPCTRANSPORTEXPORT Pusher {
  Pusher(std::string name, double *v) {
    parameters.push_back(name);
    values.push_back(v);
  }
};
struct IMPNPCTRANSPORTEXPORT IntPusher {
  IntPusher(std::string name, IntArg *v) {
    int_parameters.push_back(name);
    int_values.push_back(v);
  }
};

struct IMPNPCTRANSPORTEXPORT RangePusher {
  RangePusher(std::string name, double lb, double ub, int steps,
              double *v) {
    Range range;
    range.name=name;
    range.lb=lb;
    range.ub=ub;
    range.value=v;
    range.steps=steps;
    ranges.push_back(range);
  }
};

struct IMPNPCTRANSPORTEXPORT IntRangePusher {
  IntRangePusher(std::string name, int lb, int ub, int steps, IntArg *v) {
     IntRange range;
     range.name=name;
     range.lb=lb;
     range.ub=ub;
     range.value=v;
     range.steps=steps;
  int_ranges.push_back(range);
  }

};


IMP_NPC_PARAMETER(work_unit, -1, "The work unit to use");
IMP_NPC_PARAMETER(number_of_work_units, -1, "The total number of work units");
IMP_NPC_PARAMETER(attraction_spring_constant, 1,
                  "The spring constant for attractions");
IMP_NPC_PARAMETER(repulsion_spring_constant, 1,
                  "The spring constant for soft sphere repulsions");
IMP_NPC_PARAMETER(time_step, 10000, "The step size in fs");
IMP_NPC_PARAMETER_INT(dump, -1, "Dump the structure every n steps to ");
IMP_NPC_PARAMETER_BOOL(show_key, false, "Show the csv key");
IMP_NPC_PARAMETER_BOOL(show_number_of_work_units, false,
 "Show work units and exit");
IMP_NPC_PARAMETER(box_size, 1000, "The width of the box");
IMP_NPC_PARAMETER(slack, 10, "The slack value to use for the non-bonded list.");
IMP_NPC_PARAMETER_INT(number_of_trials, 1000,
                  "How many times to run the computation");
IMP_NPC_PARAMETER_INT(number_of_fg_beads, 10,
                  "How many beads to have in each FG repeat.");
IMP_NPC_PARAMETER_INT(number_of_fg, 10,
                  "How many fg repeat chains to have.");
IMP_NPC_PARAMETER(radius_of_fg, 10, "The radius of each FG bead.");
IMP_NPC_PARAMETER(fg_D_factor, 1, "The factor to multiply the native D by");
IMP_NPC_PARAMETER(rest_length_factor, .8,
              "The spring rest length as a fraction of the touching distance");
IMP_NPC_PARAMETER(number_interactions_of_fg, 1,
              "The number of interactions an fg bead can have");
IMP_NPC_PARAMETER(radius_of_0, 25, "The radius of particle type 0");
IMP_NPC_PARAMETER(radius_of_1, 10, "The radius of particle type 1");
IMP_NPC_PARAMETER(radius_of_2, 50, "The radius of particle type 2");
IMP_NPC_PARAMETER_INT(number_of_0, 100, "The number of particles of type 0");
IMP_NPC_PARAMETER_INT(number_of_1, 100, "The number of particles of type 1");
IMP_NPC_PARAMETER_INT(number_of_2, 100, "The number of particles of type 2");
IMP_NPC_PARAMETER_INT(number_interactions_of_0, 10,
              "The number of interactions an type 0 bead can have");
IMP_NPC_PARAMETER_INT(number_interactions_of_1, 10,
              "The number of interactions an type 1 bead can have");
IMP_NPC_PARAMETER_INT(number_interactions_of_2, 10,
              "The number of interactions an type 2 bead can have");
IMP_NPC_PARAMETER_INT(number_of_frames, 100000,
              "The number of frames to use");
IMP_NPC_PARAMETER_INT(grid_index_0, -1,
                      "The 0th grid index");
IMP_NPC_PARAMETER_INT(grid_index_1, -1,
                      "The 0th grid index");
IMP_NPC_PARAMETER_INT(grid_index_2, -1,
                      "The 0th grid index");
IMP_NPC_PARAMETER_INT(grid_index_3, -1,
                      "The 0th grid index");
IMP_NPC_PARAMETER_INT(grid_index_4, -1,
                      "The 0th grid index");
IMP_NPC_PARAMETER_INT(grid_index_5, -1,
                      "The 0th grid index");
IMP_NPC_PARAMETER_INT(grid_index_6, -1,
                      "The 0th grid index");




#ifndef IMP_NPC_GOOGLE
IMP_NPC_PARAMETER_BOOL(help, false, "Print help");
#endif



void write_key(std::ostream &out) {
  for (unsigned int i=0; i< parameters.size(); ++i) {
    if (i!=0) {
      out << ", ";
    }
    out << parameters[i];
  }
  for (unsigned int i=0; i< int_parameters.size(); ++i) {
    out << ", ";
    out << int_parameters[i];
  }
  out << std::endl;
}
void write_csv(std::ostream &out) {
  for (unsigned int i=0; i< values.size(); ++i) {
    if (i!= 0) out << ", ";
    out << *values[i];
  }
  for (unsigned int i=0; i< int_values.size(); ++i) {
    out << ", ";
    out << *int_values[i];
  }
  out << std::endl;
}



inline void npc_handle_assignments() {
  if (FLAGS_work_unit<0 && !FLAGS_show_number_of_work_units) return;
  typedef IMP::algebra::grids::DenseGridStorageD<-1, int> Storage;
  typedef IMP::algebra::grids::LogEmbeddingD<-1> Embedding;
  typedef IMP::algebra::grids::GridD<-1, Storage, int, Embedding> Grid;
  int num= ranges.size()+int_ranges.size();
  IMP::Ints steps(num);
  IMP::algebra::VectorKD lb= IMP::algebra::get_zero_vector_kd(num);
  IMP::algebra::VectorKD ub= IMP::algebra::get_zero_vector_kd(num);
  IMP::algebra::VectorKD factors(IMP::Floats(lb.get_dimension(),2.0));
  for (unsigned int i=0; i< ranges.size(); ++i) {
    lb[i]=ranges[i].lb;
    ub[i]=ranges[i].ub;
    factors[i]=2.0;
    steps[i]= ranges[i].steps;
  }
  for (unsigned int i=ranges.size();
       i< ranges.size()+int_ranges.size(); ++i) {
    lb[i]=int_ranges[i-ranges.size()].lb;
    ub[i]=int_ranges[i-ranges.size()].ub;
    factors[i]=1.0;
    steps[i]= int_ranges[i-ranges.size()].steps;
  }
  Grid g(steps,
         Embedding(IMP::algebra::BoundingBoxKD(IMP::algebra::VectorKD(lb),
                                               IMP::algebra::VectorKD(ub)),
                   factors,
                   steps, true));
  Grid::AllIndexIterator it= g.all_indexes_begin();
  unsigned int nv= g.get_number_of_voxels();
  if (FLAGS_show_number_of_work_units) {
    std::cout << "number of work units is " << nv << std::endl;
    exit(0);
  }
  if (FLAGS_work_unit >= nv) {
     std::cerr << "Invalid work unit " << FLAGS_work_unit
               << " >= " << nv << std::endl;
     throw IMP::ValueException("Bad work unit");
  }
  if (FLAGS_number_of_work_units > 0
      && FLAGS_number_of_work_units != nv) {
    std::cerr << "Mismatched work unit count "
              << FLAGS_number_of_work_units
               << " != " << nv << std::endl;
     throw IMP::ValueException("Mismatched work units");
  }
  IMP_USAGE_CHECK(FLAGS_work_unit < nv,
                  "Not enough voxels" << nv);
  std::advance(it, FLAGS_work_unit);
  IMP::algebra::VectorKD center= g.get_center(*it);
  //std::cout << *it << " yields " << center  << std::endl;
  for (unsigned int i=0; i< center.get_dimension(); ++i) {
    switch (i) {
      case 0:
        FLAGS_grid_index_0=it->operator[](i);
        break;
      case 1:
        FLAGS_grid_index_1=it->operator[](i);
        break;
      case 2:
        FLAGS_grid_index_2=it->operator[](i);
        break;
      case 3:
        FLAGS_grid_index_3=it->operator[](i);
        break;
      case 4:
        FLAGS_grid_index_4=it->operator[](i);
        break;
      case 5:
        FLAGS_grid_index_5=it->operator[](i);
        break;
    }
    if (i < ranges.size()) {
      *ranges[i].value=center[i];
    } else {
      *int_ranges[i-ranges.size()].value=center[i];
      IMP_USAGE_CHECK(*int_ranges[i-ranges.size()].value
                      >= int_ranges[i-ranges.size()].lb
                      && *int_ranges[i-ranges.size()].value
                      <= int_ranges[i-ranges.size()].ub,
                      "Out of range: " << *int_ranges[i-ranges.size()].value
                      << " " << int_ranges[i-ranges.size()].lb
                      << " " <<  int_ranges[i-ranges.size()].ub);
    }
  }
}


>>>>>>> .r12575
using namespace IMP;
using namespace IMP::npctransport;
using namespace IMP::atom;
using namespace IMP::core;
using namespace IMP::container;
using namespace IMP::display;
using namespace IMP::algebra;
using namespace RMF;


#endif // IMP_NPC_MAIN
#endif /* IMPNPCTRANSPORT_MAIN_H */
